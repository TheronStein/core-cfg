<%*
/** 
* Time to display Messages/Notifications
**/
const mTimer = 8000;

const myTemplates = ["Note", "View"] ; //const myTemplates = ["Note", "Meeting", "Contact", "Organisation","Circle","Venture","Workstream","Product","Component"];

// ------- (Helper) Functions ---------------------------------------------------------

/** 
* 'deleteOnCancel' & 'deleteNote:
* When this flow gets triggered a new note was just created by Obsidian.
* 'deleteOnCancel' controls if that note should be trashed via
* 'deleteNote', should the user cancel out of the workflow.
* - true : Delete the note
* - false: Don't delete the note
**/
const deleteOnCancel = true;

/** 
* 'deleteNote':  
* @param TFile: Instance of an Obsidian note object
* @param enabled: If 'true', try to delete the note
* Checks Obsidian settings for the behaviour configured
* to deal with the deletion of a note and
* attempts to delete the note that triggered
* the workflow.
**/
async function deleteNote(TFile, enabled) {
	if( enabled ) {
		let mPart = "";
		// local = Obsidian trash, system = system trash, none = delete
		switch (trashOption = app.vault.config.trashOption) {
			case "system":
				await app.vault.trash(TFile, true);
				mPart = "The file\n\n" +TFile.name + "\n\nwas sent to the system's trash!";
				break;
			case "local":
				await app.vault.trash(TFile, false);
				mPart = "The file\n\n" +TFile.name + "\n\nwas sent to\nObsidian's .trash folder!";
				break;
			case undefined:
			case "none":
				await app.vault.delete(TFile,false);
				mPart = "The file\n\n" +TFile.name + "\n\nhas been deleted!";
				break;
			default:
				mPart = "The Obsidian setting \n\n 'Files and links > Deleted files'\n\n";
				mPart += "is set to an option unknown to this template.\n";
				mPart += "The option identified is: " + trashOption;
				//console.log("trashOption set to unknown value:" +trashOption);
		}
		new tp.obsidian.Notice(mPart, mTimer);
		//console.log("trashOption:" + trashOption);
	}
	return;
}

/** 
* Asks the user for his Template/Note choice
* via a modal generated by tp.system.suggester
* Uses the 'myTemplates' array defined at the
* top of the script.
**/

/** 
* Ask the user to choose a target folder for the new note
* if optional fBase is provided, filter folder tree by fBase
* if optional fWhere is provided, filter by fBase at -1 = start, 1 = end, 0 = contains
**/
async function selectFolder(fBase,fWhere) {
	if ( fBase === undefined ) {
		folders = this.app.vault.getAllLoadedFiles().filter(i => i.children).map(folder => folder.path);
	} else {
		if ( (fWhere === undefined) || (fWhere === 0 ) ) {
			folders = this.app.vault.getAllLoadedFiles().filter(i => i.children).map(folder => folder.path).filter(p => p.contains(fBase));
		} else if ( fWhere === -1 ) {
			folders = this.app.vault.getAllLoadedFiles().filter(i => i.children).map(folder => folder.path).filter(p => p.startsWith(fBase));
		} else if ( fWhere === 1 ) {
			folders = this.app.vault.getAllLoadedFiles().filter(i => i.children).map(folder => folder.path).filter(p => p.endsWith(fBase));
		} else {
			throw new Error('(Syrup) selectFolder: Invalid value for "fWhere" - must be -1,0 or 1');		
		}
	}
	const folderPath = await tp.system.suggester(folders, folders, false, "Choose a folder for the new file");
	return folderPath
}

/** 
* Ask the user for a note name if template was not called from a "dead link".
* The function identifies whether it should asked based on the title of
* the note that triggered the workflow.
* When the name starts with 'Unitled' we assume that the workflow
* was not triggered from a link.
* Otherwise we won't ask and take the name provded by the link.
* Should the user add any invalid characters, replace them
**/
async function askFileName(){
  let fName = tp.file.title;
  //console.log("Note Name=" +fName)
  if (fName.startsWith("Untitled")) {
    fName = await tp.system.prompt("Please provide a Filename");
    // A file name cannot contain any of the 
    // following characters: * " \ / < > : | ?
    // ...replace any occurance with underscore
	if ( fName ){
		fName = fName.replace(/[^\w\s]/gi, '_');
	}
  } 
  return fName;
}

/**
* Move file to folder selected via 'selectFolder()'
* Makes 5 attempts to add a suffix to the file name
* if a file by the same name already exists in the target folder
* Adopted from: https://github.com/SilentVoid13/Templater/discussions/625
**/
async function moveFile(path, name, times = 1) {
	if (times > 5) {
		throw new Error('(Syrup) moveFile: Too many tries')
	}
	try {
		let newName = name;
		if (times > 1) newName = `${name} (${times})`;
		await tp.file.move( path + "/" + newName);
		return newName
	} catch(err) {
		return moveFile(path, name, times +1)
	}
}

**/
let templateApplied = false;
switch( template ){
	case "View":
		newFolder = await selectFolder();
		tp.file.title = await askFileName();
		//console.log(newFolder, tp.file.title);
		if( newFolder && tp.file.title) {
			tp.file.title = await moveFile(`${newFolder}`,`${tp.file.title}`);
			output = await tp.file.include("[[!1-WorkSpaces/JavaScript/Templater/New Note]]");
			templateApplied = true;
		}
		break;
	case "Note":
		newFolder = await selectFolder();
		tp.file.title = await askFileName();
		if( newFolder && tp.file.title) {	
			fDate = tp.date.now("YYMMDD")
			tp.file.title = await moveFile(`${newFolder}`, `${fDate}` + " - " + `${tp.file.title}`);
			await setClassification();
			output = await tp.file.include("[[meeting_general]]");
			templateApplied = true;
		}
		break;
	default:
	templatedApplied = false;
}
if( !templateApplied ){
	new tp.obsidian.Notice("No template applied.\nDid you cancel the workflow?", mTimer);
	await deleteNote(myTFile,deleteOnCancel);
	return;
}

tR +=`${output}` 


function LoadSnippets() {




		dv.el('div',
			createButton({
				app,
				el: that.container,
				args: { name: btnStr, color: 'blue' },
				clickOverride: { click: this.getEditApi(), params: [updateSct, this.processItems(this.getPoint(dv.page(.), updateSct), false), dv.page("pagename.md").file.path]}
			}),
		)
}


snippetsMenu



async getEditApi() {
	const { EnhancedMenuItem } = app.plugins.plugins["mysnippet"].api
return await EnhancedMenuItem
}

}

%>

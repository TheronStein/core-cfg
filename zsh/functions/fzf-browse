#!/usr/bin/env zsh
# fzf-browse - Interactive directory browser with toggleable layouts
# Location: $CORE_CFG/zsh/functions/fzf-browse
#
# Features:
# - Horizontal grid view (preview top, compact list bottom)
# - Vertical detailed view (eza long format with icons)
# - Toggle between views with Ctrl-V
# - Toggle sort (alpha/recent) with Ctrl-S
# - Preview files/directories prominently
# - Navigate into directories with Enter
# - Go up with Ctrl-U or ..

# ============================================================================
# Configuration
# ============================================================================
typeset -g FZF_BROWSE_PREVIEW_RATIO=65
typeset -g FZF_BROWSE_DEFAULT_VIEW="horizontal"  # horizontal or vertical
typeset -g FZF_BROWSE_DEFAULT_SORT="alpha"       # alpha or recent

# ============================================================================
# Helper: Generate horizontal grid listing
# ============================================================================
_fzf_browse_horizontal_list() {
    local dir="${1:-.}"
    local sort_mode="${2:-alpha}"

    if command -v eza &>/dev/null; then
        if [[ "$sort_mode" == "recent" ]]; then
            eza --icons --color=always -a --sort=modified "$dir" 2>/dev/null
        else
            eza --icons --color=always -a --sort=name "$dir" 2>/dev/null
        fi
    else
        if [[ "$sort_mode" == "recent" ]]; then
            ls -t --color=always -A "$dir" 2>/dev/null
        else
            ls --color=always -A "$dir" 2>/dev/null
        fi
    fi
}

# ============================================================================
# Helper: Generate vertical detailed listing
# ============================================================================
_fzf_browse_vertical_list() {
    local dir="${1:-.}"
    local sort_mode="${2:-alpha}"

    if command -v eza &>/dev/null; then
        if [[ "$sort_mode" == "recent" ]]; then
            eza --icons --color=always -la --sort=modified --time-style=relative --no-permissions --no-user "$dir" 2>/dev/null
        else
            eza --icons --color=always -la --sort=name --time-style=relative --no-permissions --no-user "$dir" 2>/dev/null
        fi
    else
        if [[ "$sort_mode" == "recent" ]]; then
            ls -lAht --color=always "$dir" 2>/dev/null
        else
            ls -lAh --color=always "$dir" 2>/dev/null
        fi
    fi
}

# ============================================================================
# Helper: Generate header with directory grid (for horizontal view)
# ============================================================================
_fzf_browse_header_grid() {
    local dir="${1:-.}"
    local cols=$(( $(tput cols) - 4 ))

    # Colors
    local C=$'\033[1;36m'
    local M=$'\033[1;35m'
    local D=$'\033[0;90m'
    local R=$'\033[0m'

    echo "${M}╣ ${C}$(pwd)${M} ╠${R}"
    echo "${D}─────────────────────────────────────────────────────────────────────${R}"

    if command -v eza &>/dev/null; then
        eza --icons --color=always -a --sort=name --grid "$dir" 2>/dev/null | head -8
    else
        ls --color=always -A "$dir" 2>/dev/null | head -20 | pr -t -4 -w"$cols"
    fi

    echo "${D}─────────────────────────────────────────────────────────────────────${R}"
    echo "${D}Enter:open │ Ctrl-U:up │ Ctrl-V:view │ Ctrl-S:sort │ Esc:quit${R}"
}

# ============================================================================
# Helper: Preview for files/directories
# ============================================================================
_fzf_browse_preview() {
    local target="$1"
    local dir="${2:-.}"
    local full_path

    # Handle relative paths
    if [[ "$target" == /* ]]; then
        full_path="$target"
    else
        full_path="$dir/$target"
    fi

    # Clean up path (remove icon prefixes if present from eza)
    full_path="${full_path//[[:space:]][[:space:]]/ }"

    # Colors
    local C=$'\033[1;36m'
    local M=$'\033[1;35m'
    local G=$'\033[1;32m'
    local Y=$'\033[1;33m'
    local D=$'\033[0;90m'
    local R=$'\033[0m'

    if [[ -d "$full_path" ]]; then
        echo "${M}╣ DIRECTORY ╠${R} ${C}${full_path}${R}"
        echo ""
        if command -v eza &>/dev/null; then
            eza --icons --color=always -la --sort=name --group-directories-first "$full_path" 2>/dev/null | head -30
        else
            ls -lAh --color=always "$full_path" 2>/dev/null | head -30
        fi
        echo ""
        local count=$(find "$full_path" -maxdepth 1 2>/dev/null | wc -l)
        echo "${D}Items: $((count - 1))${R}"
    elif [[ -f "$full_path" ]]; then
        echo "${G}╣ FILE ╠${R} ${C}${full_path}${R}"
        echo ""
        # Show file info
        local size=$(du -h "$full_path" 2>/dev/null | cut -f1)
        local modified=$(stat -c '%y' "$full_path" 2>/dev/null | cut -d'.' -f1)
        echo "${D}Size: ${R}${size}  ${D}Modified: ${R}${modified}"
        echo ""

        # Preview content based on file type
        local mime=$(file -b --mime-type "$full_path" 2>/dev/null)
        case "$mime" in
            text/*|application/json|application/javascript|application/xml)
                if command -v bat &>/dev/null; then
                    bat --style=numbers,changes --color=always --line-range=:50 "$full_path" 2>/dev/null
                else
                    head -50 "$full_path"
                fi
                ;;
            image/*)
                echo "${Y}[Image]${R} $mime"
                if command -v chafa &>/dev/null; then
                    chafa -s 60x30 "$full_path" 2>/dev/null
                elif command -v viu &>/dev/null; then
                    viu -w 60 "$full_path" 2>/dev/null
                fi
                ;;
            application/pdf)
                echo "${Y}[PDF Document]${R}"
                if command -v pdftotext &>/dev/null; then
                    pdftotext -l 2 "$full_path" - 2>/dev/null | head -40
                fi
                ;;
            *)
                echo "${D}[Binary: $mime]${R}"
                hexdump -C "$full_path" 2>/dev/null | head -20
                ;;
        esac
    else
        echo "${D}No preview available${R}"
    fi
}

# ============================================================================
# Main browser function
# ============================================================================
fzf-browse() {
    local start_dir="${1:-$(pwd)}"
    local current_dir="$start_dir"
    local view_mode="${FZF_BROWSE_DEFAULT_VIEW}"
    local sort_mode="${FZF_BROWSE_DEFAULT_SORT}"
    local selected

    # Create preview script
    local preview_script="${CORE_CFG:-$HOME/.core/.sys/cfg}/zsh/scripts/fzf-browse-preview"

    while true; do
        cd "$current_dir" || break

        # Build the listing based on view mode
        local list_cmd header_text preview_pos

        if [[ "$view_mode" == "horizontal" ]]; then
            # Horizontal: grid in header, preview on top
            preview_pos="up:${FZF_BROWSE_PREVIEW_RATIO}%"
            header_text=$(_fzf_browse_header_grid "$current_dir")
            list_cmd="_fzf_browse_horizontal_list '$current_dir' '$sort_mode'"
        else
            # Vertical: detailed list, preview on right
            preview_pos="right:${FZF_BROWSE_PREVIEW_RATIO}%"
            header_text=$'╣ '"$(pwd)"$' ╠\n───────────────────────────────────────────────────────\nEnter:open │ Ctrl-U:up │ Ctrl-V:view │ Ctrl-S:sort │ Esc:quit'
            list_cmd="_fzf_browse_vertical_list '$current_dir' '$sort_mode'"
        fi

        # Run fzf
        selected=$(eval "$list_cmd" | \
            fzf --ansi \
                --header="$header_text" \
                --header-first \
                --prompt="Browse❯ " \
                --height=95% \
                --layout=reverse \
                --border=double \
                --preview="'$preview_script' {} '$current_dir'" \
                --preview-window="$preview_pos:wrap" \
                --bind="ctrl-u:abort+execute(echo '__..__')" \
                --bind="ctrl-v:abort+execute(echo '__toggle_view__')" \
                --bind="ctrl-s:abort+execute(echo '__toggle_sort__')" \
                --bind="enter:accept" \
                --bind="esc:abort" \
                --expect="ctrl-u,ctrl-v,ctrl-s")

        # Parse the result
        local key=$(echo "$selected" | head -1)
        local choice=$(echo "$selected" | tail -1)

        # Handle special keys
        case "$key" in
            ctrl-u)
                current_dir=$(dirname "$current_dir")
                continue
                ;;
            ctrl-v)
                if [[ "$view_mode" == "horizontal" ]]; then
                    view_mode="vertical"
                else
                    view_mode="horizontal"
                fi
                continue
                ;;
            ctrl-s)
                if [[ "$sort_mode" == "alpha" ]]; then
                    sort_mode="recent"
                else
                    sort_mode="alpha"
                fi
                continue
                ;;
        esac

        # Handle selection
        if [[ -z "$choice" ]]; then
            # User pressed Esc
            break
        fi

        # Extract actual filename (strip eza icons and formatting)
        # eza icons are typically at the start followed by space
        local clean_choice=$(echo "$choice" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' | awk '{print $NF}')

        # Also try getting just the filename for vertical view
        if [[ "$view_mode" == "vertical" ]]; then
            # In vertical mode, last field is the filename
            clean_choice=$(echo "$choice" | awk '{print $NF}')
        fi

        local target="$current_dir/$clean_choice"

        if [[ -d "$target" ]]; then
            current_dir="$target"
        elif [[ -f "$target" ]]; then
            # Return the selected file
            echo "$target"
            break
        fi
    done

    cd "$start_dir"
}

# ============================================================================
# Widget for ZLE integration
# ============================================================================
fzf-browse-widget() {
    local result=$(fzf-browse)
    if [[ -n "$result" ]]; then
        LBUFFER+="$result"
    fi
    zle redisplay
}

# Register widget
zle -N fzf-browse-widget

# ============================================================================
# Quick directory jump variant
# ============================================================================
fzf-cd() {
    local start_dir="${1:-$(pwd)}"
    local current_dir="$start_dir"
    local selected

    local preview_script="${CORE_CFG:-$HOME/.core/.sys/cfg}/zsh/scripts/fzf-browse-preview"

    while true; do
        cd "$current_dir" || break

        # List only directories
        local dirs
        if command -v eza &>/dev/null; then
            dirs=$(eza --icons --color=always -a -D --sort=name 2>/dev/null)
        else
            dirs=$(find . -maxdepth 1 -type d ! -name '.' -printf '%f\n' 2>/dev/null | sort)
        fi

        selected=$(echo "$dirs" | \
            fzf --ansi \
                --header="$(pwd)"$'\n'"Enter:cd │ Ctrl-U:up │ Ctrl-A:accept │ Esc:cancel" \
                --header-first \
                --prompt="cd❯ " \
                --height=60% \
                --layout=reverse \
                --border=rounded \
                --preview="'$preview_script' {} '$current_dir'" \
                --preview-window="right:50%:wrap" \
                --bind="ctrl-u:abort+execute(echo '__up__')" \
                --bind="ctrl-a:abort+execute(echo '__accept__')" \
                --expect="ctrl-u,ctrl-a")

        local key=$(echo "$selected" | head -1)
        local choice=$(echo "$selected" | tail -1)

        case "$key" in
            ctrl-u)
                current_dir=$(dirname "$current_dir")
                continue
                ;;
            ctrl-a)
                # Accept current directory
                cd "$current_dir"
                echo "Changed to: $current_dir"
                return 0
                ;;
        esac

        if [[ -z "$choice" ]]; then
            cd "$start_dir"
            return 1
        fi

        local clean_choice=$(echo "$choice" | awk '{print $NF}')
        local target="$current_dir/$clean_choice"

        if [[ -d "$target" ]]; then
            current_dir="$target"
        fi
    done
}

# CD widget
fzf-cd-widget() {
    fzf-cd
    zle reset-prompt
}
zle -N fzf-cd-widget

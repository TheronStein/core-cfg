# ━━━Hooks━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [[[

# show-hooks [-gpw]    [-t target-pane]
# set-hook   [-agpRuw] [-t target-pane] hook-name command
#   -a  → append to hook
#   -g  → add hook to global list
#   -p  → set pane hooks
#   -R  → run hook immediately
#   -t  → specify target session
#   -u  → unset a hook
#   -w  → set window hooks

# client-active           when a client becomes the latest active client of its session.
# client-focus-in         when focus enters a client
# client-focus-out        when focus exits a client
# client-resized          when a client is resized.
# client-session-changed  when a client's attached session is changed.
# pane-died               when the program running in a pane exits, but remain-on-exit is on so the pane has not closed.
# pane-exited             when the program running in a pane exits.
# pane-focus-in           when the focus enters a pane, if the focus-events option is on.
# pane-focus-out          when the focus exits a pane, if the focus-events option is on.
# pane-set-clipboard      when the terminal clipboard is set using the xterm(1) escape sequence.
# session-created         when a new session created.
# session-closed          when a session closed.
# window-linked           when a window is linked into a session.
# window-renamed          when a window is renamed.
# window-resized          when a window is resized.  This may be after the client-resized hook is run.
# window-unlinked         when a window is unlinked from a session.

# Auto hide pane-border-status line when only one pane is displayed (see tmux/tmux#566)
# set-hook -g after-new-session  { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -g after-new-window   { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -g after-kill-pane    { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -wg window-linked      { if -F '#{==:#{window_panes},1}' 'display "link one"' 'display "link two"' }
# set-hook -wg window-unlinked    { if -F '#{==:#{window_panes},1}' 'display "unlink one"' 'display "unlink two"' }
# set-hook -p after-join-pane    { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -p after-break-pane    { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -g pane-exited        { if -F '#{==:#{window_panes},1}' 'set pane-border-status off' 'set pane-border-status on' }
# set-hook -g after-split-window { run -b "if [ #{window_panes} -gt 1 ]; then tmux set pane-border-status top; fi" }

# set-hook -g after-rename-window 'set-window-option automatic-rename off; set-window-option allow-rename off'

# set-hook -g after-resize-pane {
#   if -F '#{||:#{==:#{window_panes},1},#{window_zoomed_flag}}' {
#     set -g pane-border-status off
#   } {
#     set -g pane-border-status top
#   }
# }
# set-hook -g after-new-session 'run-shell "printf \"\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\007\""'
# set-hook -g client-session-changed 'run-shell "printf \"\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\007\""'
# set-hook -g after-rename-session 'run-shell "printf \"\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\007\""'
# set-hook -g client-attached 'run-shell "printf \"\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\007\""'
#
# set-hook -g after-split-window { select-pane -T "" }
# set-hook -g after-new-window   { select-pane -T "" }
# set-hook -g after-new-session  { select-pane -T "" }

# Allow for respawning windows after the command has exited
# set-hook -g session-created 'set remain-on-exit on'

# set-hook -ga client-focus-in  { set -w status on }
# set-hook -ga client-focus-out { set -w status off }
# set-hook -ga client-focus-in[0]  { setw -g  window-status-format "#[fg=$neoncyan] #W " }
# set-hook -ga client-focus-out[0] { setw -g  window-status-format "#[fg=$lightcyan] #W " }

# ============================================================================
# WEZTERM INTEGRATION - Event-Driven Cleanup
# ============================================================================
# Notify WezTerm when clients detach from sessions so it can cleanup orphaned views
# This uses OSC 1337 escape sequences to send custom user variables to WezTerm

# When a client detaches from a session, trigger cleanup
# Note: We only care about view sessions (with -view- in the name)
set-hook -g client-detached 'run-shell "if echo #{session_name} | grep -q -- \"-view-\"; then printf \"\\033]1337;SetUserVar=TMUX_CLEANUP_TRIGGER=$(echo -n detach:#{session_name}:#{client_session} | base64)\\007\" > #{pane_tty}; fi"'

# When a session closes, trigger cleanup
set-hook -g session-closed 'run-shell "if echo #{session_name} | grep -q -- \"-view-\"; then printf \"\\033]1337;SetUserVar=TMUX_CLEANUP_TRIGGER=$(echo -n closed:#{session_name} | base64)\\007\" > #{pane_tty}; fi"'

# ============================================================================
#
# WEZTERM INTEGRATION HOOKS
# ============================================================================
# NOTE: These hooks are also defined in hooks.conf - duplicates commented out here
# Send tmux session name to WezTerm via OSC sequences
# This allows WezTerm to display the current tmux session in its UI
set-hook -g after-new-session 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty}"'
set-hook -g client-session-changed 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty}"'
set-hook -g after-rename-session 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty}"'
set-hook -g client-attached 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty}"'

# ============================================================================
# PANE RENUMBERING
# ============================================================================
# Automatically renumber panes when one is killed
set-hook -g after-kill-pane[0] 'run-shell "~/.core/cfg/tmux/scripts/renumber-panes.sh"'

# ============================================================================
# LAYOUT MANAGER - FIXED DIMENSION PANES
# ============================================================================
# Restore locked pane dimensions after any layout-affecting operation
set-hook -g after-split-window 'run-shell "~/.core/cfg/tmux/scripts/layout-manager.sh restore"'
set-hook -g after-kill-pane[2] 'run-shell "~/.core/cfg/tmux/scripts/layout-manager.sh restore"'
set-hook -g window-resized 'run-shell "~/.core/cfg/tmux/scripts/layout-manager.sh restore"'
set-hook -g after-select-layout 'run-shell "~/.core/cfg/tmux/scripts/layout-manager.sh restore"'

# Cleanup non-existent panes from lock list when panes exit
set-hook -g pane-exited 'run-shell "~/.core/cfg/tmux/scripts/layout-manager.sh cleanup"'

# ============================================================================
# YAZI SIDEBAR - SESSION-SCOPED DOCKED SIDEBAR
# ============================================================================
# DISABLED: after-split-window hook causes infinite loop during sidebar creation
# The sidebar-manager creates splits, which trigger this hook, which calls ensure,
# which may recreate the sidebar, triggering another split, etc.
# set-hook -g after-split-window[10] 'run-shell "~/.core/cfg/tmux/scripts/yazi-sidebar-manager.sh ensure"'

# DISABLED: after-kill-pane hook can interfere with normal pane management
# The pane-exited hook below handles sidebar cleanup properly
# set-hook -g after-kill-pane[10] 'run-shell "~/.core/cfg/tmux/scripts/yazi-sidebar-manager.sh ensure"'

# DISABLED: after-select-window hook is too aggressive and can cause issues
# Users can manually focus sidebar with Alt+g if needed
# set-hook -g after-select-window 'run-shell "~/.core/cfg/tmux/scripts/yazi-sidebar-manager.sh ensure"'

# DISABLED: window-resized hook can cause issues during split operations
# Layout manager handles dimension restoration separately
# set-hook -g window-resized[10] 'run-shell "~/.core/cfg/tmux/scripts/yazi-sidebar-manager.sh ensure"'

# Note: Hook indices [10] ensure sidebar operations run after layout restoration

# Clear sidebar tracking if the tracked pane is manually killed
set-hook -g pane-exited[10] 'run-shell "
    if [ \"#{pane_id}\" = \"$(tmux show-option -qv @yazi-sidebar-pane-id)\" ]; then
        # Unlock the sidebar pane
        ~/.core/cfg/tmux/scripts/layout-manager.sh unlock \"#{pane_id}\"
        # Don't clear, let ensure recreate it
        if [ \"$(tmux show-option -qv @yazi-sidebar-enabled)\" = \"1\" ]; then
            ~/.core/cfg/tmux/scripts/yazi-sidebar-manager.sh ensure
        else
            tmux set-option -qu @yazi-sidebar-pane-id
        fi
    fi
    if [ \"#{pane_id}\" = \"$(tmux show-option -qv @yazi-preview-pane-id)\" ]; then
        tmux set-option -qu @yazi-preview-pane-id
    fi
"'

# ============================================================================
# GPG AGENT - Refresh GPG_TTY on new panes/windows
# ============================================================================
# Update GPG_TTY when creating new panes to prevent stale TTY issues
set-hook -g after-split-window[20] 'run-shell "tmux setenv -t #{session_name} GPG_TTY #{pane_tty}"'
set-hook -g after-new-window[20] 'run-shell "tmux setenv -t #{session_name} GPG_TTY #{pane_tty}"'

# ]]]

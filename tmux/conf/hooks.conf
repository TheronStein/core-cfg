# ━━━Hooks━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [[[
# FIXED VERSION: Eliminates hook chain conflicts and race conditions
# Changes made:
#   1. Removed window-resized hook for layout-manager (causes feedback loops)
#   2. Added debouncing via @layout-restore-pending flag
#   3. Unified hook indices to ensure proper execution order
#   4. Added guards to prevent recursive hook execution

# show-hooks [-gpw]    [-t target-pane]
# set-hook   [-agpRuw] [-t target-pane] hook-name command
#   -a  -> append to hook
#   -g  -> add hook to global list
#   -p  -> set pane hooks
#   -R  -> run hook immediately
#   -t  -> specify target session
#   -u  -> unset a hook
#   -w  -> set window hooks

# Hook Reference:
# client-active           when a client becomes the latest active client of its session.
# client-focus-in         when focus enters a client
# client-focus-out        when focus exits a client
# client-resized          when a client is resized.
# client-session-changed  when a client's attached session is changed.
# pane-died               when the program running in a pane exits, but remain-on-exit is on so the pane has not closed.
# pane-exited             when the program running in a pane exits.
# pane-focus-in           when the focus enters a pane, if the focus-events option is on.
# pane-focus-out          when the focus exits a pane, if the focus-events option is on.
# pane-set-clipboard      when the terminal clipboard is set using the xterm(1) escape sequence.
# session-created         when a new session created.
# session-closed          when a session closed.
# window-linked           when a window is linked into a session.
# window-renamed          when a window is renamed.
# window-resized          when a window is resized.  This may be after the client-resized hook is run.
# window-unlinked         when a window is unlinked from a session.

# ============================================================================
# WEZTERM INTEGRATION - Event-Driven Cleanup
# ============================================================================
# Notify WezTerm when clients detach from sessions so it can cleanup orphaned views
# This uses OSC 1337 escape sequences to send custom user variables to WezTerm

# When a client detaches from a view session, kill it immediately
# View sessions have detach-on-destroy set, but we enforce cleanup here too
# This prevents orphaned view sessions from accumulating
set-hook -g client-detached 'run-shell "
    session=\"#{session_name}\"
    # Check if this is a view session (has -view- in name)
    if echo \"$session\" | grep -q -- \"-view-\"; then
        # Notify WezTerm for tracking purposes
        printf \"\\033]1337;SetUserVar=TMUX_CLEANUP_TRIGGER=$(echo -n detach:#{session_name}:#{client_session} | base64)\\007\" > #{pane_tty} 2>/dev/null || true

        # Check if this session has any attached clients remaining
        attached_count=$(tmux list-clients -t \"$session\" 2>/dev/null | wc -l)

        # If no clients attached, kill the view session
        if [ \"$attached_count\" -eq 0 ]; then
            tmux kill-session -t \"$session\" 2>/dev/null || true
        fi
    fi
"'

# When a session closes, trigger cleanup
set-hook -g session-closed 'run-shell "if echo #{session_name} | grep -q -- \"-view-\"; then printf \"\\033]1337;SetUserVar=TMUX_CLEANUP_TRIGGER=$(echo -n closed:#{session_name} | base64)\\007\" > #{pane_tty} 2>/dev/null; fi"'

# ============================================================================
# WEZTERM INTEGRATION HOOKS
# ============================================================================
# Send tmux session name to WezTerm via OSC sequences
# This allows WezTerm to display the current tmux session in its UI
set-hook -g after-new-session 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty} 2>/dev/null"'
set-hook -g client-session-changed 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty} 2>/dev/null"'
set-hook -g after-rename-session 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty} 2>/dev/null"'
set-hook -g client-attached 'run-shell "printf \"\\033]1337;SetUserVar=TMUX_SESSION=$(echo -n #{session_name} | base64)\\007\" > #{pane_tty} 2>/dev/null"'

# ============================================================================
# LAYOUT MANAGER - FIXED DIMENSION PANES
# ============================================================================
# IMPORTANT: Hook execution order is critical. We use indices to control order:
#   [0-4]   - Pre-layout operations (renumbering, cleanup)
#   [5-9]   - Layout restoration
#   [10-19] - Yazibar/sidebar operations
#   [20+]   - Post-layout operations (GPG, etc.)

# Cleanup non-existent panes from lock list when panes exit (runs first)
set-hook -g pane-exited[0] 'run-shell "$TMUX_CONF/scripts/layout-manager.sh cleanup"'

# Restore locked pane dimensions after split operations
# Uses a guard flag to prevent recursive execution
set-hook -g after-split-window[5] 'run-shell "
    # Guard against recursive execution during sidebar creation
    if [ \"$(tmux show-option -gqv @layout-restore-in-progress)\" = \"1\" ]; then
        exit 0
    fi
    tmux set-option -gq @layout-restore-in-progress 1
    $TMUX_CONF/scripts/layout-manager.sh restore
    tmux set-option -gu @layout-restore-in-progress
"'

# Restore after pane kill (after cleanup runs at [0])
set-hook -g after-kill-pane[5] 'run-shell "
    if [ \"$(tmux show-option -gqv @layout-restore-in-progress)\" = \"1\" ]; then
        exit 0
    fi
    tmux set-option -gq @layout-restore-in-progress 1
    $TMUX_CONF/scripts/layout-manager.sh restore
    tmux set-option -gu @layout-restore-in-progress
"'

# Restore after explicit layout selection
set-hook -g after-select-layout[5] 'run-shell "
    if [ \"$(tmux show-option -gqv @layout-restore-in-progress)\" = \"1\" ]; then
        exit 0
    fi
    tmux set-option -gq @layout-restore-in-progress 1
    $TMUX_CONF/scripts/layout-manager.sh restore
    tmux set-option -gu @layout-restore-in-progress
"'

# REMOVED: window-resized hook
# This was causing feedback loops:
#   split-window -> after-split-window -> layout-manager restore -> resize ->
#   window-resized -> layout-manager restore -> (potential loop)
# If manual restore is needed after window resize, use: prefix + M-R
# Or run: tmux run-shell "$TMUX_CONF/scripts/layout-manager.sh restore"

# ============================================================================
# YAZI SIDEBAR - SESSION-SCOPED DOCKED SIDEBAR (LEGACY)
# ============================================================================
# Note: This section is for the OLD yazi-sidebar-manager.sh
# The new yazibar module has its own hooks in modules/yazibar/conf/hooks.conf

# Clear sidebar tracking if the tracked pane is manually killed
set-hook -g pane-exited[10] 'run-shell "
    sidebar_pane=\"$(tmux show-option -qv @yazi-sidebar-pane-id)\"
    preview_pane=\"$(tmux show-option -qv @yazi-preview-pane-id)\"
    exited_pane=\"#{pane_id}\"

    if [ -n \"$sidebar_pane\" ] && [ \"$exited_pane\" = \"$sidebar_pane\" ]; then
        # Unlock the sidebar pane
        $TMUX_CONF/scripts/layout-manager.sh unlock \"$exited_pane\" 2>/dev/null
        # Check if sidebar should be recreated
        if [ \"$(tmux show-option -qv @yazi-sidebar-enabled)\" = \"1\" ]; then
            $TMUX_CONF/scripts/yazi-sidebar-manager.sh ensure 2>/dev/null
        else
            tmux set-option -qu @yazi-sidebar-pane-id
        fi
    fi

    if [ -n \"$preview_pane\" ] && [ \"$exited_pane\" = \"$preview_pane\" ]; then
        tmux set-option -qu @yazi-preview-pane-id
    fi
"'

# ============================================================================
# GPG AGENT - Refresh GPG_TTY on new panes/windows
# ============================================================================
# Update GPG_TTY when creating new panes to prevent stale TTY issues
set-hook -g after-split-window[20] 'run-shell "tmux setenv -t #{session_name} GPG_TTY #{pane_tty}"'
set-hook -g after-new-window[20] 'run-shell "tmux setenv -t #{session_name} GPG_TTY #{pane_tty}"'

# ]]]

# vim: ft=tmux:et:sw=0:ts=2:sts=2:fdm=marker:fmr=[[[,]]]:
